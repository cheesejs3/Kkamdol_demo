<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Pure JS Image Slider</title>
    <style>
    * { margin: 0; box-sizing: border-box; }
    
    html, body {
        /* ⭐️⭐️⭐️ 최종 방어: 뷰포트 완전 고정 (가장 중요) ⭐️⭐️⭐️ */
        height: 100% !important; 
        width: 100% !important;
        
        /* 브라우저 스크롤 레이어와 DOM 분리 */
        position: fixed; 
        top: 0;
        left: 0;
        
        /* 오버스크롤 및 수직 스크롤 완벽 봉쇄 */
        overscroll-behavior: none !important;
        overflow: hidden !important;         
    }

    /* ⭐️ 슬라이드 컨테이너: JS가 제어할 순수한 영역 ⭐️ */
    .swiper {
        width: 100vw;
        height: 100vh;
        min-height: 100svh;
        background-color: black;
        
        /* 순수 JS 제어를 위해 모든 스크롤/터치 관련 CSS 제거 */
        overflow: hidden !important; 
        
        /* JS 터치 핸들러와 함께 최강의 방어 */
        touch-action: none !important; 
    }
    
    /* ⭐️ 슬라이드 래퍼: JS가 transform을 적용할 대상 ⭐️ */
    .swiper-wrapper {
        display: flex; 
        height: 100%; 
        width: max-content; 
        /* JS 트랜지션을 위한 속성 추가 */
        transition: transform 0.3s ease-out; 
    }
    
    /* ⭐️ 개별 슬라이드: 100vw 강제 고정 ⭐️ */
    .swiper-slide {
        width: 100vw; 
        height: 100%; 
        display: flex;
        align-items: center; 
        justify-content: center;
        flex-shrink: 0; 
        padding: 0 16px; 
    }
    
    img, video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        /* 드래그, 긴눌림 메뉴 방지 (유지) */
        -webkit-user-drag: none;
        user-select: none;
    }
    
    .info-overlay{
        color:white;
        position: fixed;
        top:0;
        left: 0;
        display: none; 
        padding: 10px;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 10;
    }
</style>

</head>
<body>
    <div class="swiper">
        <div class="swiper-wrapper" id="swiper-wrapper-id">
        </div>
    </div>
    
<script>
    // ----------------------------------------------------
    // [1] 환경 설정 및 변수
    // ----------------------------------------------------
    const CLOUDINARY_CLOUD_NAME = 'dbmdkatry';
    const CLOUDINARY_BASE_URL = `https://res.cloudinary.com/${CLOUDINARY_CLOUD_NAME}/`;
    const JSON_FILE_PATH = 'photos.json'; 
    
    let isDragging = false;
    let startX = 0;
    let currentTranslate = 0;
    let currentIndex = 0;
    let slideCount = 0;
    
    let wrapper = null; 

    // ----------------------------------------------------
    // [2] 유틸리티 함수
    // ----------------------------------------------------

    /** URL에서 'date' 쿼리 파라미터를 추출하는 함수 */
    function getInitialDateFromUrl() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('date'); 
    }

    /** 파일명 문자열을 분석하여 데이터 객체로 변환하는 함수 */
    function parseFilename(filename) {
        if (typeof filename !== 'string' || filename.length === 0) {
            console.error("파일명 데이터가 유효하지 않습니다:", filename);
            return null;
        }
        const basename = filename.substring(0, filename.lastIndexOf('.'));
        const parts = basename.split('_');
        if (parts.length < 5) {
            console.error("파일명 형식이 올바르지 않습니다:", filename);
            return null;
        }
        const [datePart, timePart, locationPart, peoplePart, actionPart] = parts;
        let time;
        if (timePart.length === 2) {
            time = `${timePart}:00:00`;
        } else if (timePart.length === 6) {
            time = `${timePart.substring(0, 2)}:${timePart.substring(2, 4)}:${timePart.substring(4, 6)}`;
        } else {
            time = timePart; 
        }
        const locationSplit = locationPart.split('-');
        const locationSubcategory = locationSplit.length > 1 ? locationSplit[1] : locationSplit[0];
        const people = peoplePart.split('-').join(', ');
        const actionSplit = actionPart.split('-');
        const action = actionSplit[0] || 'N/A';
        const emotion = actionSplit[1] || 'N/A';
        const situation = actionSplit[2] || 'N/A';

        return {
            filename: filename,
            date: datePart,
            time: time,
            locationSubcategory: locationSubcategory,
            people: people,
            action: action,
            emotion: emotion,
            situation: situation
        };
    }

    /** 파일 목록을 기반으로 슬라이드 HTML을 생성하고 삽입하는 함수 */
    function generateSwiperSlides(filenames) {
        let swiperSlidesHTML = '';

        filenames.forEach(filename => {
            const data = parseFilename(filename);

            if (data) {
                const isVideo = filename.toLowerCase().endsWith('.webm') || filename.toLowerCase().endsWith('.mp4');
                const resourceType = isVideo ? 'video' : 'image'; 
                const imagePath = `${CLOUDINARY_BASE_URL}${resourceType}/upload/${filename}`; 
                
                let mediaTag;

                if (isVideo) {
                    const posterFilename = filename.replace(/\.[^/.]+$/, '.jpg'); 
                    const posterPath = `${CLOUDINARY_BASE_URL}video/upload/f_jpg/${posterFilename}`;
                    
                    mediaTag = `
                        <video 
                            src="${imagePath}"  
                            controls  
                            muted  
                            loop 
                            preload="metadata" 
                            playsinline
                            poster="${posterPath}"
                            aria-label="${data.date} - ${data.locationSubcategory}"
                            style="width: 100%; height: 100%; object-fit: contain;"
                        >
                            Your browser does not support the video tag.
                        </video>
                    `;
                } else {
                    mediaTag = `
                        <img src="${imagePath}"  
                             alt="${data.date} - ${data.locationSubcategory}"
                             style="width: 100%; height: 100%; object-fit: contain;">
                    `;
                }
                
                const slideHTML = `
                    <div class="swiper-slide">
                        ${mediaTag} 
                        <div class="info-overlay">
                            <p><strong>날짜</strong>: ${data.date}</p>
                            <p><strong>시간</strong>: ${data.time}</p>
                            <p><strong>장소</strong>: ${data.locationSubcategory}</p>
                            <p><strong>사람</strong>: ${data.people}</p>
                            <p><strong>행동</strong>: ${data.action}</p>
                            <p><strong>감정</strong>: ${data.emotion}</p>
                            <p><strong>상황</strong>: ${data.situation}</p>
                        </div>
                    </div>
                `;
                swiperSlidesHTML += slideHTML;
            }
        });

        wrapper.innerHTML = swiperSlidesHTML;
    }


    // ----------------------------------------------------
    // [3] JS 슬라이드 핵심 로직
    // ----------------------------------------------------
    
    // transform CSS 업데이트 함수
    function setWrapperTranslate(x) {
        if(wrapper) {
            wrapper.style.transform = `translateX(${x}px)`;
        }
    }

    // 슬라이드 이동 (터치 종료 시 스냅)
    function snapToSlide(draggedDistance) {
        // 목표 인덱스 계산
        const threshold = 0.25; // 화면 폭의 25% 이상 움직여야 슬라이드 인정
        const slideWidth = wrapper.offsetWidth / slideCount;
        
        // 🔥🔥🔥 스와이프 방향 논리 수정 🔥🔥🔥
        // draggedDistance = startX - endX; (양수: R->L, 음수: L->R)
        
        if (Math.abs(draggedDistance) > slideWidth * threshold) {
            if (draggedDistance > 0 && currentIndex < slideCount - 1) { // R->L 드래그 (양수) -> 다음 슬라이드
                currentIndex++; 
            } else if (draggedDistance < 0 && currentIndex > 0) { // L->R 드래그 (음수) -> 이전 슬라이드
                currentIndex--; 
            }
        }
        
        // 최종 위치 계산 및 이동
        currentTranslate = -currentIndex * slideWidth;
        setWrapperTranslate(currentTranslate);
        
        // ⭐️ 미디어 재생/정지 수동 처리 ⭐️
        handleMediaPlayback();
    }
    
    // 비디오/미디어 재생 및 정지 수동 처리
    function handleMediaPlayback() {
        const slides = wrapper.querySelectorAll('.swiper-slide');
        slides.forEach((slide, index) => {
            const video = slide.querySelector('video');
            if (video) {
                if (index === currentIndex) {
                    // 현재 슬라이드의 비디오 재생
                    video.load(); 
                    video.play().catch(e => console.log("Manual Video Play Error:", e));
                } else {
                    // 다른 슬라이드의 비디오 정지
                    video.pause();
                }
            }
        });
    }

    // ----------------------------------------------------
    // [4] 순수 JavaScript 터치 핸들러 (새로고침 최종 차단)
    // ----------------------------------------------------
    
    function handleTouchStart(e) {
        // 🔥🔥🔥 가장 중요: 터치 시작 시 브라우저 동작 강제 차단 🔥🔥🔥
        e.preventDefault(); 
        
        startX = e.touches[0].clientX;
        isDragging = true;
        
        // 트랜지션 효과 잠시 제거 (드래그 중 부드럽게 움직이도록)
        wrapper.style.transition = 'none';
    }

    function handleTouchMove(e) {
        if (!isDragging) return;
        
        // 🔥🔥🔥 가장 중요: 이동 중에도 브라우저 동작 강제 차단 🔥🔥🔥
        e.preventDefault(); 
        
        const deltaX = e.touches[0].clientX - startX;
        setWrapperTranslate(currentTranslate + deltaX);
    }

    function handleTouchEnd(e) {
        if (!isDragging) return;
        
        isDragging = false;
        
        // 드래그 종료 후 다시 트랜지션 효과 추가 (스냅 시 부드럽게)
        wrapper.style.transition = 'transform 0.3s ease-out';
        
        const endX = e.changedTouches[0].clientX;
        const draggedDistance = startX - endX; // 양수: 오른쪽에서 왼쪽 (다음 슬라이드 방향)
        
        // 최종적으로 슬라이드 위치를 계산하고 이동 (스냅)
        snapToSlide(draggedDistance);
    }


    // ----------------------------------------------------
    // [5] 메인 실행 로직 영역
    // ----------------------------------------------------

    document.addEventListener('DOMContentLoaded', () => {
        
        wrapper = document.getElementById('swiper-wrapper-id');
        
        // 🔥🔥🔥 { passive: false }를 사용하여 터치 이벤트 제어권 강제 확보 🔥🔥🔥
        // 이 코드가 새로고침 방지의 핵심입니다.
        wrapper.addEventListener('touchstart', handleTouchStart, { passive: false });
        wrapper.addEventListener('touchmove', handleTouchMove, { passive: false });
        wrapper.addEventListener('touchend', handleTouchEnd);
        
        const loadingIndicator = wrapper; // 로딩 인디케이터로 wrapper 재사용
        loadingIndicator.innerHTML = `
            <div class="swiper-slide" style="color:white; font-size: 20px; display:flex; justify-content:center; align-items:center;">
                <p>데이터 로딩 중...</p>
            </div>`;


        fetch(JSON_FILE_PATH)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(loadedFilenames => {
                if (Array.isArray(loadedFilenames) && loadedFilenames.length > 0) {
                    
                    slideCount = loadedFilenames.length;
                    
                    // 1. 슬라이드 HTML 생성
                    generateSwiperSlides(loadedFilenames);
                    
                    // 2. 초기 슬라이드 위치 설정
                    const initialDate = getInitialDateFromUrl(); 
                    if (initialDate) {
                        const firstMatchingIndex = loadedFilenames.findIndex(filename => filename.substring(0, 10) === initialDate);
                        if (firstMatchingIndex !== -1) {
                            currentIndex = firstMatchingIndex;
                        }
                    }
                    
                    // 초기 위치 계산 및 적용
                    window.requestAnimationFrame(() => {
                        const slideWidth = wrapper.offsetWidth / slideCount; 
                        currentTranslate = -currentIndex * slideWidth;
                        setWrapperTranslate(currentTranslate);
                        
                        // 초기 비디오 재생
                        handleMediaPlayback();
                    });
                    
                } else {
                    console.error("JSON 파일에 유효한 파일명 배열이 없거나 비어 있습니다.");
                    loadingIndicator.innerHTML = '<div class="swiper-slide" style="color:red; font-size: 20px;">오류: JSON 파일이 비어 있습니다.</div>';
                }
            })
            .catch(error => {
                console.error("JSON 파일 로딩 중 오류 발생:", error);
                loadingIndicator.innerHTML = 
                    `<div class="swiper-slide" style="color:red; font-size: 20px; padding: 20px; text-align: center;">
                        데이터 로드 실패: ${error.message}
                        <p style="font-size: 0.8em; margin-top: 10px;">(Cloudinary Public ID, ` + JSON_FILE_PATH + ` 경로 확인 필요)</p>
                    </div>`;
            });
    });
</script>
</body>
</html>
