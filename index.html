<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, black-translucent">
    <link href="https://cdn.jsdelivr.net/gh/sun-typeface/SUIT@2/fonts/variable/woff2/SUIT-Variable.css" rel="stylesheet">
    <title></title>
    <style>
        *{margin: 0;
        font-family: 'SUIT Variable', sans-serif;}

        body{ width:100vw;
            height: 100vh;
            background-image: linear-gradient(-2deg, #a29990 -20%, #dfd9d8 30%);
            background-attachment: fixed;}

         #calendar-grid {
            display: grid;
            /* 한 줄에 7개의 동일한 크기 열 생성 */
            grid-template-columns: repeat(7, 1fr); 
            gap: 5px; /* 칸 간격 */
            max-width: 800px;
            margin: 0 auto;
            padding: 10px;
            padding-top: calc(env(safe-area-inset-top) + 30px + 3em);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        #year-grid{
            box-sizing: border-box;
            position: fixed;
            z-index: 100;
            display: grid;
            grid-template-columns: repeat(5, 1fr); 
            max-width: 800px;
            width: 100%;
            padding-top: calc(env(safe-area-inset-top) + 10px );
            padding-left:10px;
            padding-right: 10px;
            font-weight: 400;
            font-size:1em;
            letter-spacing: -0.018em;
            top: 30px;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #year-grid > div {
            padding:10px 15px;
            margin: 0 auto;
            align-items: center;
            justify-content: center;
            border-radius: 30rem;
            background-color: rgba(244, 244, 244, 0.5);
            box-shadow: inset 0 0 0.3rem rgba(244, 244, 244, 0.8);
            backdrop-filter: blur(3px);
        }

        .calendar-cell {
            overflow: hidden;
            /* 날짜 칸의 기본 스타일 */
            aspect-ratio: 1/1;
            border: 1px solid #ddd;
            border-radius: 20%;
            display: flex; 
            flex-direction: column;
            align-items: center;
            justify-content: center; 
            padding: 5px;
            box-sizing: border-box;
            font-size: 14px;
            position: relative;
            
        }
        
        .date-number {
            font-weight: bold;
            font-size: 1.2em;
        }

        .empty-cell {
            background-color: transparent; 
            border: none;
        }


        .year-color-0 { } /* 연한 하늘색 */
        .year-color-1 { background-color: #fce4ec; } /* 연한 분홍색 */
        .year-color-2 { background-color: #fffde7; } /* 연한 노란색 */
        .year-color-3 { background-color: #e8f5e9; } /* 연한 녹색 */
        .year-color-4 { background-color: #ede7f6; } /* 연한 보라색 */
        
        /* 월별 구분자: 일반 셀과 동일한 크기 유지 */
        .month-separator {
            /* ✨ 월 구분자: 1칸만 차지하며, 연속된 흐름에 삽입됩니다. */
            /* grid-column: 1 / span 7; 속성을 제거하여 1칸만 차지하도록 합니다. */
            box-shadow: inset 0 0 0.3rem rgba(244, 244, 244, 0.8);
            
            background-color: unset;
            color: white;
            font-size: 1.74em;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .date-day-link {
            text-decoration: none;
            color: inherit;
        }
    
    </style>
</head>
<body>
    <div id="year-grid">
        <div id="btn2021">2021</div>
        <div id="btn2022">2022</div>
        <div id="btn2023">2023</div>
        <div id="btn2024">2024</div>
        <div id="btn2025">2025</div>
    </div>
    <div id="calendar-grid">
    </div>

<script>
    // ----------------------------------------------------
    // 1. 데이터 생성 함수 (월 간격 빈 칸 채우기 로직 제거)
    // ----------------------------------------------------
    function generateContiguousCalendarItems(startDateStr, endDateStr) {
        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);
        const calendarItems = [];
        
        let currentDate = new Date(startDate);
        let currentMonth = startDate.getMonth();
        let currentYear = startDate.getFullYear();

        const startYear = startDate.getFullYear();
        
        // 1. 시작 월의 월별 구분자 추가 (4월)
        calendarItems.push({ 
            type: 'month', 
            value: `${currentMonth + 1}`,
            year: currentYear,
            colorIndex: (currentYear - startYear) % 5
        });

        while (currentDate <= endDate) {
            const date = currentDate.getDate();
            const month = currentDate.getMonth();
            const year = currentDate.getFullYear();
            
            const colorIndex = (year - startYear) % 5; 
            
            // 2. 월이 바뀌면 (1일이 되면) 월별 구분자 추가
            if (date === 1 && (month !== currentMonth || year !== currentYear)) {
                
                // 🔥🔥🔥 핵심 수정: 월이 바뀔 때, 이전 월의 마지막 주가 7열을 채우도록 빈 셀 추가 로직을 제거함
                
                calendarItems.push({ 
                    type: 'month', 
                    value: `${month + 1}`,
                    year: year,
                    colorIndex: colorIndex
                });
                
                currentMonth = month;
                currentYear = year;
            }

            // 3. 날짜 셀 추가
            calendarItems.push({
                type: 'day',
                value: date,
                fullDate: currentDate.toISOString().split('T')[0],
                year: year,
                colorIndex: colorIndex
            });

            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // 4. 마지막 날짜 이후 남은 빈칸 채우기 (최종 그리드 완성도를 위해 유지)
        while (calendarItems.length % 7 !== 0) {
             calendarItems.push({ type: 'empty' });
        }
        
        return calendarItems;
    }

    // ----------------------------------------------------
    // 2. 썸네일 존재 여부 체크 및 데이터 확장 함수 (유지)
    // ----------------------------------------------------
    function fetchDayData(item) {
        if (item.type !== 'day') {
            return Promise.resolve(item);
        }
        
        const thumbnailPath = `thumb/${item.fullDate}.webp`; 
        
        return fetch(thumbnailPath, { method: 'HEAD' })
            .then(response => {
                if (response.ok) {
                    return { ...item, hasThumbnail: true, thumbnailPath: thumbnailPath };
                } else {
                    return { ...item, hasThumbnail: false };
                }
            })
            .catch(error => {
                console.error(`썸네일 존재 확인 중 오류 발생 (${thumbnailPath}):`, error);
                return { ...item, hasThumbnail: false };
            });
    }

    // ----------------------------------------------------
    // 3. 모든 데이터를 준비하고 렌더링을 시작하는 비동기 메인 함수 (유지)
    // ----------------------------------------------------
    async function prepareAndRenderCalendar() {
        // 날짜 범위는 사용자의 실제 데이터에 맞게 조정하세요.
        const START_DATE = '2021-04-25'; 
        const END_DATE = '2021-09-08';
        const calendarData = generateContiguousCalendarItems(START_DATE, END_DATE);
        
        const preparedDataPromises = calendarData.map(fetchDayData);
        const finalCalendarData = await Promise.all(preparedDataPromises);
        
        renderCalendarGrid(finalCalendarData);
        setupScrollButtons();
    }


    // ----------------------------------------------------
    // 4. 최종 렌더링 함수 (동기) (유지)
    // ----------------------------------------------------
    function renderCalendarGrid(calendarData) {
        const TARGET_PAGE_URL = 'specific.html';
        const gridContainer = document.getElementById('calendar-grid');
        
        gridContainer.innerHTML = '';
        
        calendarData.forEach(item => {
            const cell = document.createElement('div');
            cell.className = 'calendar-cell'; 
            
            if (item.type !== 'empty') {
                cell.className += ` year-color-${item.colorIndex}`;
            }

            if (item.type === 'month') {
                cell.className += ' month-separator'; 
                cell.textContent = item.value;
                
                gridContainer.appendChild(cell);
                
            } else if (item.type === 'empty') {
                cell.className += ' empty-cell';
                gridContainer.appendChild(cell);
                
            } else if (item.type === 'day') { 
                
                
                let elementToAppend = cell;

                if (item.hasThumbnail) { 
                    
                    const img = document.createElement('img');
                    img.src = item.thumbnailPath; 
                    img.alt = `${item.fullDate} 썸네일`;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover'; 
                    img.style.position = 'absolute';
                    img.style.top = '0';
                    img.style.left = '0';
                    img.style.zIndex = '1';
                    cell.appendChild(img);
                    
                    const link = document.createElement('a');
                    link.href = `${TARGET_PAGE_URL}?date=${item.fullDate}`; 
                    link.className = 'date-day-link'; 
                    link.appendChild(cell);
                    
                    elementToAppend = link; 

                } else {
                }
                
                gridContainer.appendChild(elementToAppend);
            }
        });
    }

    // ----------------------------------------------------
    // 5. 스크롤 버튼 통합 설정 함수 (유지)
    // ----------------------------------------------------
    function setupScrollButtons() {
        function remToPx(rem) {
            return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
        }
        
        const offsetPx = remToPx(4); 
        
        const yearButtons = [
            { id: 'btn2021', colorIndex: 0 },
            { id: 'btn2022', colorIndex: 1 },
            { id: 'btn2023', colorIndex: 2 },
            { id: 'btn2024', colorIndex: 3 },
            { id: 'btn2025', colorIndex: 4 }
        ];

        yearButtons.forEach(btn => {
            const buttonElement = document.getElementById(btn.id);
            const targetClass = `.year-color-${btn.colorIndex}`;

            if (buttonElement) {
                buttonElement.addEventListener('click', () => {
                    const targetDiv = document.querySelector(targetClass + '.date-day'); 

                    if (targetDiv) {
                        const targetRect = targetDiv.getBoundingClientRect(); 
                        const absoluteTop = targetRect.top + window.scrollY;
                        const scrollToPosition = absoluteTop - offsetPx;
                        
                        window.scrollTo({
                            top: scrollToPosition,
                            behavior: 'smooth' 
                        });
                    }
                });
            }
        });
    }

    // ----------------------------------------------------
    // 6. DOMContentLoaded 이벤트 핸들러 (유지)
    // ----------------------------------------------------
    document.addEventListener('DOMContentLoaded', () => {
        const gridContainer = document.getElementById('calendar-grid');
        gridContainer.innerHTML = `<div style="grid-column: 1 / span 7; text-align: center; padding-top: 50px;">데이터 로딩 중...</div>`;
        
        prepareAndRenderCalendar().catch(error => {
            console.error("캘린더 렌더링 중 오류 발생:", error);
            gridContainer.innerHTML = `<div style="grid-column: 1 / span 7; text-align: center; padding-top: 50px; color: red;">캘린더 로드 중 오류 발생</div>`;
        });
    });
</script>
</body>
</html>
